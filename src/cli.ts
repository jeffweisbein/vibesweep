#!/usr/bin/env node
import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { GarbageCollector } from './core/garbage-collector.js';
import { formatBytes, formatPercentage } from './utils/format.js';
import { checkLimits, getUpgradeMessage } from './core/premium-features.js';
import { TodoReporter } from './reports/todo-report.js';
import type { ProjectAnalysis } from './core/garbage-collector.js';

const program = new Command();

program
  .name('vibesweep')
  .description('Sweep away AI-generated code waste and vibe coding artifacts ðŸ§¹')
  .version('0.1.0');

program
  .command('analyze')
  .description('Analyze a project for AI-generated waste')
  .argument('<path>', 'Path to the project directory')
  .option('-p, --pattern <pattern>', 'File pattern to analyze', '**/*.{js,ts,jsx,tsx,py}')
  .option('-o, --output <format>', 'Output format (text, json)', 'text')
  .option('--todos', 'Include TODO/FIXME report')
  .action(async (path, options) => {
    const spinner = ora('Analyzing project for AI-generated waste...').start();
    
    try {
      const gc = new GarbageCollector();
      const apiKey = process.env.VIBESWEEP_API_KEY;
      
      // Quick file count check
      const { glob } = await import('glob');
      const files = await glob(options.pattern || '**/*.{js,ts,jsx,tsx,py}', {
        cwd: path,
        ignore: ['node_modules/**', 'dist/**', 'build/**', '.git/**']
      });
      
      const limits = checkLimits(files.length, apiKey);
      if (!limits.allowed) {
        spinner.fail('File limit exceeded');
        console.log('\n' + limits.message);
        process.exit(1);
      }
      
      const analysis = await gc.analyzeProject(path, options.pattern, options.todos);
      
      spinner.succeed('Analysis complete!');
      
      if (options.output === 'json') {
        console.log(JSON.stringify(analysis, null, 2));
      } else {
        displayResults(analysis);
      }
    } catch (error) {
      spinner.fail('Analysis failed');
      console.error(chalk.red(error instanceof Error ? error.message : String(error)));
      process.exit(1);
    }
  });

type Analysis = ProjectAnalysis;

function displayResults(analysis: Analysis) {
  const output = [
    '',
    chalk.bold.cyan('ðŸ§¹ Vibesweep Analysis Report'),
    chalk.gray('â”€'.repeat(50)),
    '',
    chalk.bold('ðŸ“Š Overview:'),
    `  Total files analyzed: ${chalk.yellow(analysis.totalFiles)}`,
    `  Total size: ${chalk.yellow(formatBytes(analysis.totalSize))}`,
    `  Total waste: ${chalk.red(formatBytes(analysis.totalWaste))}`,
    `  Waste percentage: ${chalk.red(formatPercentage(analysis.wastePercentage))}`,
    '',
    chalk.bold('ðŸ“ˆ Summary:'),
    `  Files with dead code: ${chalk.yellow(analysis.summary.deadCodeFiles)}`,
    `  Files with duplications: ${chalk.yellow(analysis.summary.duplicatedFiles)}`,
    `  AI-generated files: ${chalk.yellow(analysis.summary.aiGeneratedFiles)}`,
    '',
    chalk.bold('ðŸ’° Potential Savings:'),
    `  Lines of code: ${chalk.green(analysis.summary.estimatedSavings.lines.toLocaleString())}`,
    `  Disk space: ${chalk.green(formatBytes(analysis.summary.estimatedSavings.kilobytes * 1024))}`,
  ];

  if (analysis.topOffenders.length > 0) {
    output.push('', chalk.bold('ðŸš¨ Top Waste Offenders:'));
    
    analysis.topOffenders.slice(0, 5).forEach((file, index) => {
      output.push(
        '',
        `  ${index + 1}. ${chalk.yellow(file.filePath)}`,
        `     Waste Score: ${chalk.red(file.wasteScore + '%')}`,
        `     Dead Code: ${formatPercentage(file.deadCode.ratio * 100)}`,
        `     Duplication: ${formatPercentage(file.duplication.ratio * 100)}`,
        `     AI Score: ${file.aiPatterns.score}/100`
      );
      
      if (file.aiPatterns.patterns.length > 0) {
        output.push(`     Patterns: ${file.aiPatterns.patterns[0]}`);
      }
    });
  }
  
  output.push(
    '',
    chalk.gray('â”€'.repeat(50)),
    chalk.dim('Generated by Vibesweep v0.1.0')
  );
  
  console.log(output.join('\n'));
  
  // Show TODO report if requested
  if (analysis.todos && analysis.todos.length > 0) {
    const todoReporter = new TodoReporter();
    console.log(todoReporter.generateReport(analysis.todos));
  }
}

program
  .command('clean')
  .description('Remove detected waste (Pro feature)')
  .argument('<path>', 'Path to clean')
  .option('--dry-run', 'Show what would be removed without removing')
  .action(async (path, options) => {
    console.log('\n' + getUpgradeMessage('autoFix'));
  });

program
  .command('report')
  .description('Generate detailed PDF report (Pro feature)')
  .argument('<path>', 'Path to analyze')
  .action(async (path) => {
    console.log('\n' + getUpgradeMessage('report'));
  });

program
  .command('todos')
  .description('Extract all TODO/FIXME comments')
  .argument('<path>', 'Path to analyze')
  .option('-p, --pattern <pattern>', 'File pattern to analyze', '**/*.{js,ts,jsx,tsx,py}')
  .option('--markdown', 'Output as markdown')
  .action(async (path, options) => {
    const spinner = ora('Scanning for TODOs and FIXMEs...').start();
    
    try {
      const gc = new GarbageCollector();
      const analysis = await gc.analyzeProject(path, options.pattern, true);
      
      spinner.succeed('Scan complete!');
      
      if (!analysis.todos || analysis.todos.length === 0) {
        console.log('\nâœ¨ No TODOs or FIXMEs found!\n');
        return;
      }
      
      const todoReporter = new TodoReporter();
      if (options.markdown) {
        console.log(todoReporter.generateMarkdown(analysis.todos));
      } else {
        console.log(todoReporter.generateReport(analysis.todos));
      }
    } catch (error) {
      spinner.fail('Scan failed');
      console.error(chalk.red(error instanceof Error ? error.message : String(error)));
      process.exit(1);
    }
  });

program.parse();